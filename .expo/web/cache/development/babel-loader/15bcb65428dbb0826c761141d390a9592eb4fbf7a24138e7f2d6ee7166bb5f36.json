{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport Alert from \"react-native-web/dist/exports/Alert\";\nimport { initialPitData } from \"../Models/PitModel\";\nimport { loadTeams } from \"./TeamLogic\";\nexport var savePitData = function () {\n  var _ref = _asyncToGenerator(function* (newPitData, TeamNumber) {\n    try {\n      var teamsJson = yield AsyncStorage.getItem('teams');\n      var teams = teamsJson ? JSON.parse(teamsJson) : [];\n      var targetTeamIndex = teams.findIndex(function (team) {\n        return team.teamNumber == TeamNumber || team.teamNumber.toString() == TeamNumber;\n      });\n      if (teams[targetTeamIndex].pitData !== undefined) {\n        Alert.alert('Data Exists', 'Do you want to replace existing data?', [{\n          text: 'Cancel',\n          style: 'cancel'\n        }, {\n          text: 'Replace',\n          onPress: function () {\n            var _onPress = _asyncToGenerator(function* () {\n              teams[targetTeamIndex].pitData = newPitData;\n              yield AsyncStorage.setItem('teams', JSON.stringify(teams));\n              yield savePitScanned(TeamNumber, false);\n              alert('Saved!');\n            });\n            function onPress() {\n              return _onPress.apply(this, arguments);\n            }\n            return onPress;\n          }()\n        }], {\n          cancelable: false\n        });\n      } else {\n        teams[targetTeamIndex].pitData = newPitData;\n        yield AsyncStorage.setItem('teams', JSON.stringify(teams));\n        alert('Saved!');\n      }\n    } catch (error) {\n      console.error('Error saving pit data:', error);\n      throw error;\n    }\n  });\n  return function savePitData(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var loadPitData = function () {\n  var _ref2 = _asyncToGenerator(function* (currentTeamNumber) {\n    try {\n      var teams = yield loadTeams();\n      var targetTeam = teams.find(function (team) {\n        return team.teamNumber == currentTeamNumber || team.teamNumber.toString() == currentTeamNumber;\n      });\n      return targetTeam ? targetTeam.pitData || initialPitData : initialPitData;\n    } catch (error) {\n      console.error('Error loading pit data:', error);\n      return null;\n    }\n  });\n  return function loadPitData(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport var savePitScanned = function () {\n  var _ref3 = _asyncToGenerator(function* (TeamNumber, state) {\n    try {\n      var teamsJson = yield AsyncStorage.getItem(\"teams\");\n      var teams = teamsJson ? JSON.parse(teamsJson) : [];\n      var matchDataKey = 'pitData';\n      var targetTeamIndex = teams.findIndex(function (team) {\n        return team.teamNumber == TeamNumber || team.teamNumber.toString() == TeamNumber;\n      });\n      if (targetTeamIndex !== -1) {\n        teams[targetTeamIndex][matchDataKey].gotScanned = state;\n        yield AsyncStorage.setItem(\"teams\", JSON.stringify(teams));\n      } else {\n        console.log(\"Team not found\");\n      }\n    } catch (error) {\n      console.error(\"Error saving match scanned status:\", error);\n    }\n  });\n  return function savePitScanned(_x4, _x5) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport var isPitScanned = function () {\n  var _ref4 = _asyncToGenerator(function* (teamNumber) {\n    try {\n      var teamsJson = yield AsyncStorage.getItem(\"teams\");\n      var teams = teamsJson ? JSON.parse(teamsJson) : [];\n      var matchDataKey = `pitData`;\n      var targetTeam = teams.find(function (team) {\n        return team.teamNumber == teamNumber || team.teamNumber.toString() == teamNumber;\n      });\n      if (targetTeam) {\n        var _targetTeam$matchData;\n        return !!((_targetTeam$matchData = targetTeam[matchDataKey]) != null && _targetTeam$matchData.gotScanned);\n      } else {\n        console.log(\"Team not found\");\n        return false;\n      }\n    } catch (error) {\n      console.error(\"Error checking if match is scanned:\", error);\n      return false;\n    }\n  });\n  return function isPitScanned(_x6) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["AsyncStorage","Alert","initialPitData","loadTeams","savePitData","_ref","_asyncToGenerator","newPitData","TeamNumber","teamsJson","getItem","teams","JSON","parse","targetTeamIndex","findIndex","team","teamNumber","toString","pitData","undefined","alert","text","style","onPress","_onPress","setItem","stringify","savePitScanned","apply","arguments","cancelable","error","console","_x","_x2","loadPitData","_ref2","currentTeamNumber","targetTeam","find","_x3","_ref3","state","matchDataKey","gotScanned","log","_x4","_x5","isPitScanned","_ref4","_targetTeam$matchData","_x6"],"sources":["C:/Users/Noril/Documents/TechScout/logic/PitLogic.js"],"sourcesContent":["import AsyncStorage from '@react-native-async-storage/async-storage';\r\nimport { Alert } from 'react-native';\r\nimport { initialPitData } from '../Models/PitModel';\r\nimport { loadTeams } from './TeamLogic';\r\nexport const savePitData = async (newPitData, TeamNumber) => {\r\n  try {\r\n    const teamsJson = await AsyncStorage.getItem('teams');\r\n    const teams = teamsJson ? JSON.parse(teamsJson) : [];\r\n\r\n    const targetTeamIndex = teams.findIndex(team => team.teamNumber == TeamNumber || team.teamNumber.toString() == TeamNumber);\r\n    \r\n    if (teams[targetTeamIndex].pitData !== undefined) {\r\n      Alert.alert(\r\n        'Data Exists',\r\n        'Do you want to replace existing data?',\r\n        [\r\n          {\r\n            text: 'Cancel',\r\n            style: 'cancel',\r\n          },\r\n          {\r\n            text: 'Replace',\r\n            onPress: async () => {\r\n              teams[targetTeamIndex].pitData = newPitData;\r\n\r\n              await AsyncStorage.setItem('teams', JSON.stringify(teams));\r\n              await savePitScanned(TeamNumber, false);\r\n              alert('Saved!');\r\n            },\r\n          },\r\n        ],\r\n        { cancelable: false }\r\n      );\r\n    } else {\r\n      teams[targetTeamIndex].pitData = newPitData;\r\n\r\n      await AsyncStorage.setItem('teams', JSON.stringify(teams));\r\n\r\n      alert('Saved!');\r\n    }\r\n  } catch (error) {\r\n    console.error('Error saving pit data:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\n\r\nexport const loadPitData = async (currentTeamNumber) => {\r\n  try {\r\n    const teams = await loadTeams();\r\n    \r\n    const targetTeam = teams.find(team => team.teamNumber == currentTeamNumber || team.teamNumber.toString() == currentTeamNumber);\r\n\r\n    return targetTeam ? targetTeam.pitData || initialPitData : initialPitData;\r\n  } catch (error) {\r\n    console.error('Error loading pit data:', error);\r\n\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const savePitScanned = async (TeamNumber, state) => {\r\n  try {\r\n    const teamsJson = await AsyncStorage.getItem(\"teams\");\r\n    const teams = teamsJson ? JSON.parse(teamsJson) : [];\r\n    const matchDataKey = 'pitData';\r\n    const targetTeamIndex = teams.findIndex(\r\n      (team) =>\r\n        team.teamNumber == TeamNumber || team.teamNumber.toString() == TeamNumber\r\n    );\r\n\r\n    if (targetTeamIndex !== -1) {\r\n      teams[targetTeamIndex][matchDataKey].gotScanned = state;\r\n      await AsyncStorage.setItem(\"teams\", JSON.stringify(teams));\r\n\r\n    } else {\r\n      console.log(\"Team not found\");\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error saving match scanned status:\", error);\r\n  }\r\n};\r\n\r\nexport const isPitScanned = async (teamNumber) => {\r\n  try {\r\n    const teamsJson = await AsyncStorage.getItem(\"teams\");\r\n    const teams = teamsJson ? JSON.parse(teamsJson) : [];\r\n    const matchDataKey = `pitData`;\r\n\r\n    const targetTeam = teams.find(\r\n      (team) =>\r\n        team.teamNumber == teamNumber || team.teamNumber.toString() == teamNumber\r\n    );\r\n\r\n    if (targetTeam) {\r\n      return !!targetTeam[matchDataKey]?.gotScanned;\r\n    } else {\r\n      console.log(\"Team not found\");\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error checking if match is scanned:\", error);\r\n    return false;\r\n  }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
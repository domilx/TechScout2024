var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import React, { useCallback, useEffect, useRef } from 'react';
import { useDraggableNodesContext, usePanGestureContext, } from '../context';
export var ScrollState = {
    END: -1
};
var InitialLayoutRect = {
    w: 0,
    h: 0,
    x: 0,
    y: 0,
    px: 0,
    py: 0
};
export function resolveScrollRef(ref) {
    var _a, _b, _c, _d, _e, _f;
    // FlatList
    if ((_a = ref.current) === null || _a === void 0 ? void 0 : _a._listRef) {
        return (_b = ref.current._listRef) === null || _b === void 0 ? void 0 : _b._scrollRef;
    }
    // FlashList
    if ((_c = ref.current) === null || _c === void 0 ? void 0 : _c.rlvRef) {
        return (_f = (_e = (_d = ref.current) === null || _d === void 0 ? void 0 : _d.rlvRef) === null || _e === void 0 ? void 0 : _e._scrollComponent) === null || _f === void 0 ? void 0 : _f._scrollViewRef;
    }
    // ScrollView
    return ref.current;
}
export function useDraggable(options) {
    var gestureContext = usePanGestureContext();
    var draggableNodes = useDraggableNodesContext();
    var nodeRef = useRef(null);
    var offset = useRef({ x: 0, y: 0 });
    var layout = useRef(InitialLayoutRect);
    var contentSize = useRef({ w: 0, h: 0 });
    useEffect(function () {
        var pushNode = function () {
            var _a, _b;
            var index = (_a = draggableNodes.nodes.current) === null || _a === void 0 ? void 0 : _a.findIndex(function (node) { return node.ref === nodeRef; });
            if (index === undefined || index === -1) {
                (_b = draggableNodes.nodes.current) === null || _b === void 0 ? void 0 : _b.push({
                    ref: nodeRef,
                    offset: offset,
                    rect: layout,
                    contentSize: contentSize,
                    handlerConfig: options
                });
            }
        };
        var popNode = function () {
            var _a, _b;
            var index = (_a = draggableNodes.nodes.current) === null || _a === void 0 ? void 0 : _a.findIndex(function (node) { return node.ref === nodeRef; });
            if (index === undefined || index > -1) {
                (_b = draggableNodes.nodes.current) === null || _b === void 0 ? void 0 : _b.splice(index, 1);
            }
        };
        pushNode();
        return function () {
            popNode();
        };
    }, [draggableNodes.nodes, options]);
    return {
        nodeRef: nodeRef,
        offset: offset,
        draggableNodes: draggableNodes,
        layout: layout,
        contentSize: contentSize,
        gestureContext: gestureContext
    };
}
export function useScrollHandlers(options) {
    var _a = useDraggable(options), nodeRef = _a.nodeRef, gestureContext = _a.gestureContext, offset = _a.offset, layout = _a.layout, contentSize = _a.contentSize;
    var timer = useRef();
    var subscription = useRef();
    var onMeasure = useCallback(function (x, y, w, h, px, py) {
        var _a;
        layout.current = {
            x: x,
            y: y,
            w: w,
            h: h + 10,
            px: px,
            py: py
        };
        var nextlayout = contentSize.current.h <= ((_a = layout.current) === null || _a === void 0 ? void 0 : _a.h) ? null : layout.current;
        if (!nextlayout) {
            layout.current = __assign(__assign({}, InitialLayoutRect), { y: 10000 });
        }
        else {
            layout.current = nextlayout;
        }
    }, [contentSize, layout]);
    var measureAndLayout = React.useCallback(function () {
        clearTimeout(timer.current);
        timer.current = setTimeout(function () {
            var _a;
            var ref = resolveScrollRef(nodeRef);
            (_a = ref === null || ref === void 0 ? void 0 : ref.measure) === null || _a === void 0 ? void 0 : _a.call(ref, onMeasure);
        }, 500);
    }, [nodeRef, onMeasure]);
    var memoizedProps = React.useMemo(function () {
        return {
            ref: nodeRef,
            simultaneousHandlers: gestureContext.ref,
            onScroll: function (event) {
                var _a = event.nativeEvent.contentOffset, x = _a.x, y = _a.y;
                var maxOffsetX = event.nativeEvent.contentSize.width - layout.current.w;
                var maxOffsetY = event.nativeEvent.contentSize.height - layout.current.h;
                offset.current = {
                    x: x === maxOffsetX || x > maxOffsetX - 5 ? ScrollState.END : x,
                    y: y === maxOffsetY || y > maxOffsetY - 5 ? ScrollState.END : y
                };
            },
            scrollEventThrottle: 100,
            onContentSizeChange: function (w, h) {
                contentSize.current = { w: w, h: h };
                measureAndLayout();
            },
            onLayout: function () {
                var _a;
                measureAndLayout();
                (_a = subscription.current) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                subscription.current = gestureContext.eventManager.subscribe('onoffsetchange', function () {
                    measureAndLayout();
                });
            }
        };
    }, [
        contentSize,
        gestureContext.eventManager,
        gestureContext.ref,
        layout,
        measureAndLayout,
        nodeRef,
        offset,
    ]);
    return memoizedProps;
}
